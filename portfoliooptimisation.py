# -*- coding: utf-8 -*-
"""PortfolioOptimisation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MBKXpHtYMGAO-85NwZcJJPGknTNayakj
"""

import yfinance as yf
import pandas as pd
from datetime import datetime, timedelta
import numpy as np
from scipy.optimize import minimize

tickers = ["SPY", "QQQ", "BND", "GLD", "VTI"]

# Pull the current risk free rate from the Fred API - or reassign risk free rate to your preferred rate

from fredapi import Fred

fred = Fred(api_key='YOUR-API-KEY-HERE')
ten_year_treasury_rate = fred.get_series('DGS10')
risk_free_rate = ten_year_treasury_rate.iloc[-1] / 100  # Convert to decimal


print(f"Risk-free rate: {risk_free_rate:.2%}")

# Set start date to 3 years ago and end date to today

end_date = datetime.today()
start_date = end_date - timedelta(days=5*365)

adjusted_close_df = pd.DataFrame()

for ticker in tickers:
    data = yf.download(ticker, start= start_date, end = end_date)
    adjusted_close_df[ticker] = data['Close']

print(adjusted_close_df)

log_returns = np.log(adjusted_close_df / adjusted_close_df.shift(1))

log_returns = log_returns.dropna()

# Calculate Co-variance Matrix: Measures the risk of the portfolio

cov_matrix = log_returns.cov()*252

print(cov_matrix)

def std_dev(weights, cov_matrix):
  variance = weights.T @ cov_matrix @ weights
  return np.sqrt(variance)

def expected_return(weights, log_returns):
  return np.sum(log_returns.mean()*weights)*252

# Calculate Sharpe Ratio

def sharpe_ratio(weights, log_returns, cov_matrix, risk_free_rate):
  return(expected_return(weights, log_returns) - risk_free_rate)/std_dev(weights, cov_matrix)

def neg_sharpe_ratio(weights, log_returns, cov_matrix, risk_free_rate):
  return -share_ratio(weights, log_returns, cov_matrix, risk_free_rate)

# Set bounds so positions are long-only and max portfolio alocation for one security is 50%

constraints = {"type": "eq", "fun": lambda weights: np.sum(weights)-1}
bounds = [(0, 0.5) for i in range(len(tickers))]

initial_weights = np.array([1/len(tickers)]*len(tickers))
# print(initial_weights)

optimized_results = minimize(neg_sharpe_ratio, initial_weights, args=(log_returns, cov_matrix, risk_free_rate), method="SLSQP", bounds=bounds, constraints=constraints)

optimal_weights = optimized_results.x

# display optimal portfolio

print("Optimal Portfolio Weights:")
for ticker, weight in zip(tickers, optimal_weights):
    print(f"{ticker}: {weight:.2%}")

print()

optimal_portfolio_return = expected_return(optimal_weights, log_returns)
optimal_portfolio_std_dev = std_dev(optimal_weights, cov_matrix)
optimal_sharpe_ratio = sharpe_ratio(optimal_weights, log_returns, cov_matrix, risk_free_rate)

print(f"Expected Return: {optimal_portfolio_return*100:.2f}%")
print(f"Standard Deviation: {optimal_portfolio_std_dev*100:.2f}%")
print(f"Sharpe Ratio: {optimal_portfolio_std_dev:.4f}")